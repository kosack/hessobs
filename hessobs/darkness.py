from __future__ import print_function, division, absolute_import

"""

"""

from matplotlib import pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.collections import PatchCollection
from matplotlib import gridspec
from matplotlib.colors import LinearSegmentedColormap
from matplotlib.cbook import flatten
import matplotlib.patheffects as PathEffects
import numpy as np
import re
import os
import datetime
from matplotlib.dates import date2num
from matplotlib.dates import DayLocator, DateFormatter
from scipy.interpolate import UnivariateSpline
import pickle
import textwrap
from collections import defaultdict
from operator import itemgetter
import colorama  # for colorized output
from functools import lru_cache
import logging

from . import config
from .targets import _set_target_defaults, target_list_to_dict
from . import coordinates

__all__ = ["Darkness", "load_dark", "save_dark"]
colorama.init()

log = logging.getLogger(__name__)


def transit_ra(jd, utctime):
    """
    returns RA that is at zenith at the given date/time

    Arguments:
    - `jd`: julian date (integer)
    - `utctime`: utc offset from midnight (hours)
    """

    fulljd = jd + utctime / 24.0
    ra, dec = coordinates.altaz_to_radec(90.0 - 1e-50, 0.0, fulljd)
    return ra


class Darkness(object):

    """A class that creates a table of available dark times for a year
    and schedules observations within it.

    Parameters
    ----------
    darkness_filename : str
        text file containing the darkness
        information in the format 'year month day jd utc_start
        utc_end'. Can be generated by darkness.pl

    startdate : `datetime.datetime`
        specifies the starting date of the schedule -
        if not specified, the entire range in the darkness file is  used

    bins_per_hour: int
        number of time-bins per hour
        (Config.DEFAULT_BINS_PER_HOUR is used if not specified)

    efficiencies: list
        a list of data taking efficiences starting from the
        beginning to the end of the year, which will be
        interpolated.

     name: str
        Identifier for this schedule plane (e.g. "Mono"),
        which will be used in plot titles, etc.


    """

    UNFILLED = 2  # value of unfilled bins
    UNAVAILABLE = 0  # unavailable dark slots
    RESERVED = 1  # reserved space
    MIN_TIME_PER_PERIOD = 1.0

    def __init__(
        self,
        darkness_filename,
        startdate=datetime.datetime(2011, 0o1, 21),
        binsperhour=config.BINS_PER_HOUR,
        efficiencies=config.DEFAULT_MONTH_EFFICIENCIES,
        name="dark",
    ):

        self._name = name
        self._bins_per_hour = binsperhour
        self._cur_fill_order = 0
        self._cur_target_id = self.target_step
        self.targets = dict()
        self._cmap = None
        self.label_angle = -45
        self._efficiencies = efficiencies

        infile = open(darkness_filename)

        dates = []
        periods = []
        jds = []
        utc_starts = []
        utc_ends = []

        curyear = 0
        curperiod = 0
        prevstart = 0

        # ==================================================
        # Read the darkness table from a file
        # ==================================================
        for line in infile:
            (year, month, day, jd, utc_start, utc_end) = re.split("[ \t]+", line)

            year = int(year)

            date = datetime.datetime(int(year), int(month), int(day))

            # print line

            if date < startdate:
                continue

            if year > curyear and curyear == 0:
                curyear = year
                curperiod = 1

            if abs(float(utc_start)) > 1e-10:
                dates.append(date)
                periods.append("{0}-{1:02d}".format(curyear, curperiod))
                jds.append(int(jd))
                utc_starts.append(float(utc_start))
                utc_ends.append(float(utc_end))

            elif abs(float(prevstart)) > 1e-10:
                # jump to next period
                curperiod += 1

            prevstart = utc_start

        # ==================================================
        # initialize all the internal maps
        # ==================================================
        self.dates = np.array(dates)
        self.periods = np.array(periods)
        self.jds = np.array(jds)
        self.utc_starts = np.array(utc_starts)
        self.utc_ends = np.array(utc_ends)

        (
            self.map_dates,
            self.map_fdates,
            self.map_jds,
            self.map_utcs,
            self.map,
        ) = self._initDarknessMap()

        jd, utc = self.date_time_map
        ramap = transit_ra(jd, utc)
        self.ramap = np.mod(ramap.T, 24.0)
        self.ramap_nomod = np.unwrap(ramap * np.pi / 12.0, axis=1).T * 12.0 / np.pi

        self.effmap = self._initEfficiencyMap(self._efficiencies)
        self._zenithMap = None

    def colormap(self, schedmap):
        return (schedmap / self.target_step).astype(int)

    @property
    def boolmap(self):
        return self.map > (Darkness.UNAVAILABLE + 1e-10)

    @property
    def target_step(self):
        return 10

    @property
    def hours_per_map_bin(self):
        """
        read-only property, must be set in the Config before creating the
        Darkness object
        """
        return self._hours_per_map_bin

    def proposalID(self, targetinfo):
        """ return a formatted proposal id from the target dictionary """
        return "{Year}-{Seqno:03d}".format(**targetinfo)

    def getTarget(self, target):
        """Return the target data structure for the given target_id or name
        """
        if type(target) in [int, np.uint32]:
            return self.targets[target]
        else:
            tlist = self.search(target)
            if len(tlist) == 1:
                return self.targets[tlist[0]]
            elif len(tlist) == 0:
                raise ValueError('Target "{}" was not found'.format(target))
            else:
                raise ValueError('Target "{}" was ambiguous'.format(target))

    def _addTarget(self, target_id, targetinfo):
        if target_id in self.targets:
            log.debug("target {} already exists, incrementing target_id")
            return self._addTarget(target_id + 1, targetinfo)
        else:
            targetinfo["INDEX"] = target_id
            self.targets[target_id] = targetinfo
            return target_id

    @property
    def zenithMap(self):
        if self._zenithMap is None:
            self._zenithMap = self.generateZenithAngleMapByTarget()
        return self._zenithMap

    def clear(self,):
        """
        clear the filled schedule
        """

        self.map[self.boolmap] = self.UNFILLED
        self.targets = dict()
        self._cur_target_id = self.UNFILLED
        self._curcolor = 1

    def _isSubTarget(self, target_id):
        """
        returns true if the target_id is a sub-target of a parent proposal
        """
        return np.mod(target_id, self.target_step) > 0

    def newColorMap(self,):
        """ generate a new colormap next time the schedule is drawn """
        self._cmap = None
        cmfilename = "cmap-{0}.dat".format(self._name.replace(" ", "_"))
        os.remove(cmfilename)

    @property
    def cmap(self):
        """the color map to use for each target.  By default is is
        loaded from cmap.dat. If that doesn't exist, it is generated
        randomly based on the number of targets that have been
        scheduled.
        """
        if self._cmap is None:
            cmapsize = np.max(np.unique(self.colormap(self.map)))
            cmfilename = "cmap-{0}.dat".format(self._name.replace(" ", "_"))
            try:
                cmfile = open(cmfilename, "rb")
                r, g, b = pickle.load(cmfile)
                cmfile.close()
                if len(r) != cmapsize:
                    raise IndexError
            except:
                log.debug("GENERATING CMAP: {}".format(cmapsize))
                r = np.random.uniform(size=cmapsize)
                g = np.random.uniform(size=cmapsize)
                b = np.random.uniform(size=cmapsize)
                if cmapsize > 0:
                    r[0] = 0.9
                    g[0] = 0.9
                    b[0] = 0.9
                    r[2] = 0.5
                    g[2] = 0.5
                    b[2] = 0.5
                    cmfile = open(cmfilename, "wb")
                    pickle.dump((r, g, b), cmfile)
                    cmfile.close()

            if cmapsize > 0:
                self._cmap = LinearSegmentedColormap.from_list(
                    "rands", list(zip(r, g, b))
                )
        return self._cmap

    @property
    @lru_cache(maxsize=1)
    def date_time_map(self):
        """ returns 2D map of dates, utctimes """
        datemap, utcmap = np.meshgrid(self.map_jds, self.map_utcs)
        return datemap, utcmap

    def getDateRangeForPeriod(self, period):

        mask = self.periods == period
        dates = self.dates[mask]
        return (dates[0], dates[-1])

    def _initDarknessMap(self):
        """produces a boolean map of when there is usable
        dark-time. Assumes the Darnkess object has been initialized
        and that self.jds, self.dates, self.utc_starts, and
        self.utc_ends are already filled in from the darkness table.

        This generates the various maps necessary for plotting and
        filling the Darkness object. This includes the time axes:
        map_dates and map_fdates (fdates being floating-point
        representations of the dates used by Matplotlib to draw time
        axes)

        """

        jds = self.jds
        jdmin = jds[0]
        jdmax = jds[-1]
        nbins_date = jdmax - jdmin

        map_jds = np.arange(jdmin, jdmax)
        d0 = self.dates[0]
        map_dates = [d0 + datetime.timedelta(days=x) for x in range(nbins_date)]

        map_fdates = np.array([date2num(x) for x in map_dates])

        range_utc = (-6.5, 5.5)
        nbins_utc = int((range_utc[1] - range_utc[0]) * self._bins_per_hour)

        self._hours_per_map_bin = (range_utc[1] - range_utc[0]) / float(nbins_utc)

        utc_starts = self.utc_starts
        utc_ends = self.utc_ends

        map_utcs = np.linspace(range_utc[0], range_utc[1], nbins_utc)
        schedmap = np.zeros((nbins_date, int(nbins_utc)), dtype='I')

        for jd, start, end in zip(jds, utc_starts, utc_ends):
            iday = jd - jdmin
            if iday < nbins_date:
                rowmask = np.logical_and(map_utcs > start, map_utcs < end)
                schedmap[iday][rowmask] = self.UNFILLED

        return (np.array(map_dates), map_fdates, map_jds, map_utcs, schedmap)

    def _initEfficiencyMap(self, monthlyeffs):
        """
        Returns a map that contains the interpolated efficiency for each bin

        Arguments:
        `monthlyeffs`
              array of monthly efficiencies (12 months)
        """

        if len(monthlyeffs) != 12:
            raise ValueError("Month efficiencies should have 12 entries")

        spline = UnivariateSpline(np.linspace(1, 12, 12), np.array(monthlyeffs))

        ndays = len(self.map_dates)
        map_month = np.linspace(1, 12, ndays)

        effs = spline(map_month)
        effmap = np.ones(self.map.shape, dtype=float)

        for ii in range(effmap.shape[0]):
            effmap[ii] = effmap[ii] * effs[ii]

        return effmap

    def maskUnavailable(self, mask):
        """Mask off a portion of the schedule, defined by 'mask' as
        unavailable for scheduling. 'mask' must be the same dimensions
        as self.map, and shouldn't overlap already scheduled
        observations (a check is made for those cases)
        """
        if mask is None:
            return

        assert mask.shape == self.map.shape

        # check if mask overlaps anything already scheduled:
        if np.any(self.map[mask] > self.UNFILLED):
            raise RuntimeError("Mask overlaps already scheduled observations")

        self.map[mask] = self.RESERVED

    def setDatesAsUnavailable(self, startdate, enddate, value=0):
        """
        Masks off dates in the map as already filled (even if no
        target has filled them)
        """

        datemap, utcmap = self.date_time_map
        datemap = datemap.T

        startjd = self._date2jd(startdate)
        endjd = self._date2jd(enddate)

        mask = self.map == self.UNFILLED
        mask *= datemap >= startjd
        mask *= datemap <= endjd

        self.map[mask] = value

        log.info("masked: {} to {}".format(startdate, enddate))
        log.info("Set {}  bins as UNAVAILABLE".format(len(mask)))

    def periodName(self, period):
        """
        Returns the normalized name of the period. The input can
        be a string ('2011-01') or an integer (1). The output is
        always the correct period string.
        """

        if period is None:
            return None

        if not isinstance(period, str):
            year = self.dates[50].year
            period = "{0}-{1:02d}".format(year, period)

        return period

    def draw(
        self,
        maptype=None,
        period=None,
        ragrid=True,
        newfig=True,
        custommap=None,
        cmap=None,
    ):
        """display a schedule map


        Parameters
        ----------
        self: type
            description
        maptype: None or str
            'ra' for transiting RA, 'eff' for efficiencies, or 'zenith' for zenith, or 'custom' for anything else (in that case you must also specify `custommap`)
        period: int or str
            period number or name
        ragrid: bool
            if True, show RA lines
        newfig: bool
            if True, generate a new figure, otherwise use existing
        custommap: numpy.ndarray
            a map to use in the case maptype=='custom'
        cmap: matplotlib.colors.LinearSegmentedColormap
            color map to use if you don't want the auto-selected one
        """

        period = self.periodName(period)

        figsize = (15, 7)

        if period is not None:
            figsize = (8, 8)
            self.label_angle = -10
        else:
            self.label_angle = -38

        # ==========================================================
        # Setup figure
        # ==========================================================

        if newfig:
            fig = plt.figure(figsize=figsize)
        else:
            fig = plt.gcf()

        if period is not None and maptype != "custom":
            gs = gridspec.GridSpec(1, 2, width_ratios=[4, 1], wspace=0.07)
            plt.subplot(gs[1])

            self._drawLegend(period)
            ax = plt.subplot(gs[0])

        else:
            ax = plt.subplot(1, 1, 1)

        ax.xaxis_date()
        ax.xaxis.set_minor_locator(DayLocator())
        ax.xaxis.set_major_formatter(DateFormatter("%Y-%m-%d"))

        zlabel = ""
        if cmap is None:
            cmap = self.cmap

        # ==========================================================
        # Setup map
        # ==========================================================
        themap = self.colormap(self.map)
        schedmap = self.map
        fdates = self.map_fdates
        vmin = 1
        vmax = themap.max() + 1

        if maptype == "ra":
            # generate a RA plot (masking off the non-dark parts)
            themap = self.ramap
            plt.hsv()
            zlabel = "RA (h)"
            cmap = plt.cm.hsv
            vmin = None
            vmax = None
        elif maptype == "eff":
            themap = self.effmap
            zlabel = "Efficiency"
            cmap = plt.cm.winter
            vmin = None
            vmax = None
        elif maptype == "zenith":
            themap = self.zenithMap
            vmin = 0.0
            vmax = 65.0
            cmap = plt.cm.PuRd  # RdBu_r
            zlabel = "Zenith Angle (deg)"
        elif maptype == "custom":
            themap = custommap
            vmin = None
            vmax = None

        else:
            pass

        mask = self.boolmap == 0  # don't draw non-darktime
        themap = np.ma.array(themap)
        themap[mask] = np.ma.masked

        # ==========================================================
        # zoom to period
        # ==========================================================
        if period is not None:
            # zoom to selected period:
            themap, fdates = self._getPeriodSubMap(
                period, themap=themap, withdates=True
            )
            schedmap = self._getPeriodSubMap(period, themap=self.map)

            plt.title(self._name + " P" + period)

        # ==========================================================
        # Draw map
        # ==========================================================

        utcrange = [-6.5, 5.0]

        plt.ylim(utcrange[0], utcrange[1])

        plt.pcolormesh(fdates, self.map_utcs, themap.T, cmap=cmap, vmin=vmin, vmax=vmax)

        if maptype is not None and maptype != "none" and maptype != "custom":
            cb = plt.colorbar()
            cb.ax.set_ylabel(zlabel)

        # overlay areas of reserved schedule
        freemask = schedmap == self.RESERVED
        unavailable = np.ma.masked_array(schedmap, np.invert(freemask))
        plt.contourf(
            fdates,
            self.map_utcs,
            unavailable.T,
            colors=["#555555"],
            hatches=["//"],
            levels=[0, 1],
        )

        fig.autofmt_xdate(rotation=90, ha="center")
        plt.xlabel("Date")
        plt.ylabel("UTC (hrs)")
        plt.grid()

        if period is None:
            for per in np.unique(self.periods):
                self.labelPeriod(per)

        if ragrid:
            contlevels = np.arange(0, 36, 2)
            contlabels = dict()
            for lev in contlevels:
                contlabels[lev] = "{0:d}$^h$".format(np.mod(lev, 24))

            ramap, fdates = self._getPeriodSubMap(
                period, themap=self.ramap_nomod, withdates=True
            )

            cont = plt.contour(
                fdates,
                self.map_utcs,
                ramap.T,
                levels=contlevels,
                colors="b",
                linestyles="dotted",
            )
            plt.clabel(cont, use_clabeltext=True, fmt=contlabels)

        plt.connect("button_press_event", self._on_click)
        plt.connect("motion_notify_event", self._on_motion)

        fillhrs, fillhrs_corr = self.hoursForTarget(target_id=None, period=period)
        freehrs, freehrs_corr = self.hoursForTarget(self.UNFILLED, period=period)

        # if period != None:
        #     axsave = plt.axes([0.81, 0.05, 0.1, 0.075])
        #     bsave = Button(axnext, 'Save')
        #     bnext._on_clicked(self.on_save_clicked)

        if maptype != "custom":
            plt.suptitle(
                (
                    "{4} filled: {0:.1f} ({1:.1f}) h  " "  free: {2:.1f} ({3:.1f}) h"
                ).format(fillhrs, fillhrs_corr, freehrs, freehrs_corr, self._name)
            )

        return fig

    def meanMapFDateForPeriod(self, period):
        """ returns the center of the period as matplotlib
        floating-point date, useful for plotting """

        dates = self.dates[self.periods == period]
        dbin = int(len(dates) / 2)
        thedate = dates[dbin]
        return date2num(thedate)

    def labelPeriod(self, period, yval=4.75):
        """ put a label above the period """
        period = self.periodName(period)
        plt.text(
            self.meanMapFDateForPeriod(period),
            yval,
            "P" + period,
            horizontalalignment="center",
            verticalalignment="center",
            fontsize=10,
        )

    def search(self, regexp):
        """
        Search for target INDEX number, given part of the target name

        Parameters
        ----------
        regexp: str
            regular expression to match to target name
        """

        target_indices = []

        for target_id in self.targets:
            if re.match(
                regexp, self.getTarget(target_id)["Target_Name"], re.IGNORECASE
            ):
                print(
                    (
                        "{0:4.1f} {1}".format(
                            target_id, self.getTarget(target_id)["Target_Name"]
                        )
                    )
                )
                target_indices.append(target_id)

        return target_indices

    def _drawLegend(self, period=None):
        """ draw the scheduled objects legend """

        submap = self.map
        if period:
            submap = self._getPeriodSubMap(period)

        patches = []
        target_indices = np.unique(
            np.sort(submap[submap > Darkness.UNFILLED].flatten())
        )

        names = [self.targets[x]["Target_Name"] for x in target_indices]

        ax = plt.gca()
        ax.set_navigate = False

        plt.ylim(0, 1.0)
        plt.xlim(0.0, 1.0)
        plt.setp(ax, frame_on=False, xticks=(), yticks=())

        if len(target_indices) == 0:  # no legend to draw!
            return

        delta = 1.0 / float(len(target_indices))
        wid = 0.2

        fsize = 8  # default font size
        if len(names) > 15:
            fsize = 5

        for ii, (target_id, name) in enumerate(zip(target_indices, names)):

            x = 0
            y = (ii) * delta

            hours, corrhours = self.hoursForTarget(target_id, period=period)
            propid = self.proposalID(self.getTarget(target_id))

            if corrhours < self.MIN_TIME_PER_PERIOD:
                continue

            color = self.cmap(
                self.colormap(target_id - 1) / float(self.colormap(self.map).max())
            )
            plt.text(
                x + wid * 1.1,
                y + delta / 4,
                "{0} \n{1:4.1f}h ({2:4.1f}h) {3}".format(
                    name, hours, corrhours, propid
                ),
                verticalalignment="center",
                fontsize=fsize,
                fontweight="bold",
                color=color,
            )

            patches.append(Rectangle((x, y), wid, delta / 2, color=color))

        collection = PatchCollection(patches, cmap=self.cmap, match_original=True)
        ax.add_collection(collection)

    def drawRADist(self, nbins=24):
        """
        draw the RA distribution
        """

        ras = []
        hreqs = []
        hraws = []
        hcorrs = []

        for targ in self.targets.values():
            ras.append(targ["RA_2000"])
            hreqs.append(targ["Hours_Requested"])
            hraw, hcorr = self.hoursForTarget(targ["INDEX"])
            hraws.append(hraw)
            hcorrs.append(hcorr)

        ras = np.array(ras)
        hreqs = np.array(hreqs)
        hraws = np.array(hraws)
        hcorrs = np.array(hcorrs)

        fig = plt.figure()
        rng = [0, 24]

        hisreq, xbin, p = plt.hist(
            ras,
            weights=hreqs,
            bins=nbins,
            range=rng,
            label="Accepted",
            color="skyblue",
            edgecolor="white",
        )
        hisraw, xbin, p = plt.hist(
            ras,
            weights=hraws,
            bins=nbins,
            range=rng,
            label="Scheduled (100% efficiency)",
            color="orange",
            alpha=0.8,
        )
        hisexp, xbin, p = plt.hist(
            ras,
            weights=hcorrs,
            bins=nbins,
            range=rng,
            label="Scheduled (expected)",
            color="seagreen",
            alpha=0.4,
        )
        plt.legend(loc="upper left")
        plt.ylabel("Scheduled Hours")
        plt.xlabel("RA (h)")
        plt.grid()

        return

    def drawTargetPie(self, kind="scheduled"):
        """
        draws a target-type pie chart

        `kind`: scheduled, accepted, proposed
        """

        totalhrs = defaultdict(float)

        for targ in self.targets.values():
            ttype = targ["Target_Type"].capitalize()
            hrs = 0
            if kind == "scheduled":
                hrs = self.hoursForTarget(targ["INDEX"])[1]
            elif kind == "accepted":
                hrs = targ["Hours_Accepted"]
            elif kind == "proposed" or kind == "requested":
                hrs = targ["Hours_Requested"]
            else:
                raise TypeError("unknown kind: " + kind)

            totalhrs[ttype] += hrs

        if kind == "scheduled":
            totalhrs["FREE"] += self.hoursForTarget(self.UNFILLED)[1]

        keys = np.array(list(totalhrs.keys()))
        vals = np.array([totalhrs[x] for x in keys])

        mask = vals > 0
        keys = keys[mask]
        vals = vals[mask]

        vv, kk = list(zip(*sorted(zip(vals, keys))))

        labs = ["{0} ({1:.0f}h)".format(x, y) for x, y in zip(kk, vv)]

        fracs = vv / np.sum(vv)

        plt.pie(
            fracs,
            labels=labs,
            autopct="%d%%",
            colors=(
                "yellowgreen",
                "gold",
                "lightskyblue",
                "pink",
                "cyan",
                "burlywood",
                "m",
                "y",
                "orange",
                "purple",
                "w",
            ),
        )
        plt.title("{1} {0} Time".format(kind.capitalize(), self._name))

        return keys, vals

    def drawPie(self, kind="scheduled"):
        """
        draws a working-group pie chart

        `kind`: scheduled, accepted, proposed
        """

        total = 0
        wgtotal = defaultdict(float)

        for targ in self.targets.values():

            if targ["Observation_Strategy"] == "TOO":
                continue

            wgs = [targ["Working_Group"]]
            wg2 = targ["Working_Group_Secondary"].split(",")

            if targ["Working_Group_Secondary"] != "":
                wgs.append(wg2)

            for wg in flatten(wgs):
                if kind == "scheduled":
                    hrs = self.hoursForTarget(targ["INDEX"])[1]
                elif kind == "accepted":
                    hrs = targ["Hours_Accepted"]
                elif kind == "proposed" or kind == "requested":
                    hrs = targ["Hours_Requested"]
                else:
                    raise TypeError("unknown kind: " + kind)
                wgtotal[wg] += hrs
                total += hrs

        free = self.hoursForTarget(self.UNFILLED)[1]
        if kind == "scheduled":
            total += free

        log.debug("WGTOTAL: {}".format(wgtotal))
        keys = list(wgtotal.keys())
        labels = ["{0}\n({1:.0f} hrs)".format(key, wgtotal[key]) for key in keys]
        fracs = [wgtotal[key] / total for key in keys]

        if free > 0.5 and kind == "scheduled":
            labels.append("Free\n({0:.0f} hrs)".format(free))
            fracs.append(free / total)

        plt.pie(
            fracs,
            labels=labels,
            autopct="%d%%",
            colors=(
                "yellowgreen",
                "gold",
                "lightskyblue",
                "pink",
                "m",
                "y",
                "orange",
                "purple",
                "w",
            ),
        )

        plt.title("{1} {0} Time by WG".format(kind.capitalize(), self._name))

    def drawZenithAngleDist(self, target_id=None, newfig=True):
        """
        display the distribtion of predicted zenith angles in the schedule
        """

        if newfig:
            plt.figure()

        zmap = self.zenithMap
        if target_id:
            zmap = zmap[self.map == target_id]
            log.debug(("only for", self.getTarget(target_id)["Target_Name"]))

        zen = zmap.flatten()
        zen = zen[zen > 1e-10]
        plt.hist(
            zen[zen > 1e-10],
            range=[0, 80],
            bins=int(80 / 2),
            weights=np.ones_like(zen) * self.hours_per_map_bin,
            edgecolor="none",
            color="skyblue",
        )
        plt.title("{0} Predicted Zenith Angles".format(self._name))
        plt.xlabel("Zenith Angle")
        plt.ylabel("Hours")

    def _date2jd(self, date):
        """
        convert a data to julian date
        """
        result = self.map_jds[self.map_dates == date]
        if len(result):
            return result[0]
        else:
            return None

    def fillTarget(self, targetinfo, verbose=True, combine_close=True):
        """
        Fill object into the darktime map

        Parameters
        ----------
        targetinfo: dict
            Observation_Proposal database row 
        verbose: bool
            output more info when filling
        combine_close: bool
            merge targets that are in the same FOV
        """

        _set_target_defaults(targetinfo)  # sanitize just in case it
        # wasn't done before
        targetinfo["FILL_ORDER"] = self._cur_fill_order
        self._cur_fill_order += 1

        RA = targetinfo["RA_2000"]
        dec = targetinfo["Dec_2000"]
        startdate = targetinfo["Start_Date"]
        enddate = targetinfo["End_Date"]
        effmode = targetinfo["Scheduling_Efficency"]
        minfillfraction = targetinfo["Scheduling_Min_Fraction"]
        sched_preference = targetinfo["Scheduling_Preference"]
        nhours = targetinfo["Hours_Accepted"]
        startjd = None
        endjd = None

        if startdate:
            startjd = self._date2jd(startdate)
        if enddate:
            endjd = self._date2jd(enddate)

        close_ids = self.nearbyTargets(targetinfo, radius_deg=0.1)
        if combine_close and RA > 0 and len(close_ids) > 0:
            # If the target already exists in the target list (by
            # perhaps another name), combine it with the current
            # target (so don't schedule extra hours, and keep a single
            # target name and id number)
            target_id = close_ids[0]
            if verbose:
                print(
                    (
                        "APPN: Target {0} ({1}-{2:03d}) was filled as {3} ({4}-{5:03d}) and will be combined.".format(
                            targetinfo["Target_Name"],
                            targetinfo["Year"],
                            targetinfo["Seqno"],
                            self.getTarget(target_id)["Target_Name"],
                            self.getTarget(target_id)["Year"],
                            self.getTarget(target_id)["Seqno"],
                        )
                    )
                )
        else:
            # otherwise, add the target to the list of scheduled
            # targets, with a new target ID
            self._cur_target_id += self.target_step
            target_id = self._cur_target_id

        target_id = self._addTarget(target_id, targetinfo)

        # ===========================================================
        # sanity checks and filters
        # ===========================================================
        if RA < 0:
            self._addTarget(target_id, targetinfo)
            if verbose:
                print(
                    (
                        "FILL: no RA for '{0}' (TARGET_ID={1}): not filling".format(
                            targetinfo["Target_Name"], target_id
                        )
                    )
                )
            return

        # skip TOO targets
        if targetinfo["Observation_Strategy"] == "TOO":
            #            self._addTarget(target_id,targetinfo)
            if verbose:
                print(("FILL:", targetinfo["Target_Name"], " is TOO, skipping"))
            return

        if effmode == "ignore":
            print(
                (
                    "REALTIME: Target ",
                    targetinfo["Target_Name"],
                    "will be filled without efficiency correction",
                )
            )

        if nhours < 1e-10:
            return

        frequency = int(targetinfo["Scheduling_Frequency"])
        if frequency == 0:
            frequency = 1

        #  Calculate allowed zeniths:
        zmax = targetinfo["Zenith_Max"]
        zmin = targetinfo["Zenith_Min"]
        zmap = self._generateZenithAngleMap(RA, dec)

        # depending on fill strategy (time or zenith), choose number
        # of bands in zenith angle to use to fill the map:
        if sched_preference == "time":
            zbandwidth_deg = 0.0
            num_zbands = 1  # just one band in ZA
        elif sched_preference == "zenith":
            zbandwidth_deg = targetinfo["Scheduling_Zenith_Step"]
            num_zbands = np.ceil((zmax - zmin) / zbandwidth_deg)
        else:
            raise ValueError("Unknown scheduling pref: {0}".format(sched_preference))

        # ===========================================================
        # First find all possible bins where the source could be filled
        # ===========================================================

        hours_filled = 0
        bands = np.linspace(zmin, zmax, num_zbands + 1)

        tmpmap = self.map.copy()  # to test what could be filled
        startmask = tmpmap == self.UNFILLED

        datemap, utcmap = self.date_time_map
        datemap = datemap.T

        if startjd:
            startmask &= datemap > startjd
        if endjd:
            startmask &= datemap < endjd

        startmask &= zmap > zmin  # account for minimum zenith angle
        timemask = startmask.copy()

        # ===========================================================
        # now loop over each zenith band and try filling
        # ===========================================================

        for zbandmax in bands[1:]:

            mask = np.logical_and(startmask, tmpmap == self.UNFILLED)

            # ----------------------------------------------------------
            # take the requested exposure time into account, filling
            # only the bins up to the total.  If Frequency is
            # specified, use it to skip nights (for sources to be
            # spread out for monitoring)
            # ----------------------------------------------------------

            realtime = effmode == "ignore"
            mask &= zmap < zbandmax  # maximum in current band
            tmptimemask, hours = self._maskByTime(
                mask, nhours - hours_filled, frequency, realtime
            )

            hours_filled += hours
            tmpmap[tmptimemask] = target_id

        timemask = tmpmap == target_id
        del zmap
        del tmpmap

        sched = self._name[self._name.find(" ") + 1 :]

        # don't fill targets that don't meet minium hours requirement

        if (
            targetinfo["Observation_Mode"] != "survey"
            and targetinfo["Working_Group_Rank"] < 100
            and hours_filled < (minfillfraction * nhours)
        ):

            print(
                (
                    "FILL: {sched:10s} {id:3.0f} {name:30s} NOT FILLED: "
                    "Fill Fraction {frac:3.0f}% <{min:3.0f}%".format(
                        sched=sched,
                        id=target_id,
                        name=targetinfo["Target_Name"],
                        frac=100 * hours_filled / nhours,
                        min=minfillfraction * 100,
                    )
                )
            )

            self.targets[target_id]["BELOW_FILL_FRACTION"] = True
            return None

        # otherwise, fill the target into the schedule:
        self.map[timemask] = target_id

        if verbose:
            line = (
                "FILL: {sched:8s} {id:3.0f} {name:30s} RA:{ra:4.1f} STRAT:{method:7s}"
                "{nfilled:5.1f} of {nhours:5.1f} hrs "
            )
            print(
                (
                    line.format(
                        sched=sched,
                        id=target_id,
                        name=targetinfo["Target_Name"],
                        ra=RA,
                        nhours=float(nhours),
                        nfilled=hours_filled,
                        method=sched_preference,
                    )
                )
            )

        return timemask  # in case you want to plot it

    def _maskByTime(self, valid_fill_mask, nhours, frequency=1, realtime=False):
        """
        Helper function for fillTarget(). Takes in input target mask
        that describes all valid target schedule positions, and
        returns the same target mask truncated number of hours
        specified (at most nhours). Also takes into account periodic
        monitoring observations if requested.

        Parameters
        ----------
        self: type
            description
        valid_fill_mask: array(bool)
            mask giving times where scheduling can be performed
        nhours: int
            maximum number of hours to fill
        frequency: int
            fill every X days (default 1) for periodic observations
        realtime: bool
            if True, ignore efficiency when scheduling (e.g. for coordinated
            campaigns where the times are fixed)
        """

        daycount = 0
        eff = self.effmap  # per-bin efficiencies
        exceeded = False
        hours_filled = 0
        mask = valid_fill_mask.copy()

        # fill day by day in a forward direction:

        for daymask, dayeff in zip(mask, eff):

            daycount += 1

            # if a frequency is specified, only schedule on days that match
            if np.remainder(daycount, frequency) > 0:
                daymask[0:-1] = False
                continue

            # calculate the hours for this row
            hours = np.sum(dayeff[daymask] * self.hours_per_map_bin)
            rthours = np.sum(daymask * self.hours_per_map_bin)

            if realtime:
                hours = rthours

            # stop if we've filled up to nhours
            if exceeded:
                daymask[0:-1] = False
                continue

            if hours_filled + hours >= nhours:

                exceeded = True

                # Deal with partial row:
                dhours = nhours - hours_filled

                eff = dayeff.copy()
                eff[daymask == False] = 0
                effsum = np.cumsum(eff)
                daymask[effsum > dhours + 0.1] = False

                remainder = np.sum(dayeff[daymask] * self.hours_per_map_bin)
                hours_filled += remainder

            else:
                hours_filled += hours

        return mask, hours_filled

    def periodsForTarget(self, target_id):
        """
        returns list of periods where the given target is scheduled
        """

        plist = []
        for period in np.unique(self.periods):
            hrs, corrhrs = self.hoursForTarget(target_id, period=period)
            if hrs > self.MIN_TIME_PER_PERIOD:
                plist.append(period)

        return plist

    def hoursOfFreeDarkTime(self, period=None):
        """returns (darkhours, corrected_darkhours) for full year or period
        if specified)
        """
        return self.hoursForTarget(target_id=Darkness.UNFILLED, period=period)

    def hoursForTarget(self, target_id=None, period=None):
        """
        calculate (hours, efficency-corrected hours) that are filled in
        the dark map.

        Parameters
        ----------
        target_id: int
            target number
        period: int or string
            period number or name
        """
        if period is not None:
            effmap = self._getPeriodSubMap(period, themap=self.effmap)
            schmap = self._getPeriodSubMap(period)
        else:
            effmap = self.effmap
            schmap = self.map

        if target_id:
            if target_id >= self.target_step:
                mask = schmap / self.target_step == target_id / self.target_step
            else:
                mask = schmap == target_id

        else:
            mask = schmap > self.UNFILLED  # all targets

        bins_eff = np.sum(effmap[mask])
        bins = len(effmap[mask])

        return (bins * self.hours_per_map_bin, bins_eff * self.hours_per_map_bin)

    def hoursForRABand(self, minra, maxra):
        """returns number of hours (raw,est) for an RA range

        Parameters
        ----------
        minra: float
            minimum Right Ascension in hours
        maxra: float
            maximum Right Ascension in hours
        """
        ras = self.ramap * (self.map > self.UNFILLED)
        effs = self.effmap[(ras > minra) & (ras < maxra)]
        return (
            len(effs) * self.hours_per_map_bin,
            np.sum(effs) * self.hours_per_map_bin,
        )

    def s(self, **kwargs):
        """ alias for printSummary() """
        self.printSummary(**kwargs)

    def printSummary(
        self, sortkey="INDEX", filter_target=None, filter_wg=None, wrap=False
    ):
        """display the summary data in a text table.  By default all
        results are given, however you may filter by target name or wg
        using regular expressions.

        Parameters
        ----------
        self: type
            description
        sortkey: str
            target dictionary keyword to sort by
        filter_target: str
            regular expression to select Target Name
        filter_wg: str
            regular experssion to select Working Group
        wrap: bool
            word-wrap the output
        """

        line = (
            "{clr}{tid:4d} {grade:4.2f} {wg:8s} {name:30s} {pid:8s} "
            "{ra:02.0f} {req:4.0f} {hours:4.0f} "
            "| {pct:3d} {flag:4s}" + colorama.Fore.RESET
        )

        print(self._name, "Schedule Summary sorted by", sortkey)
        print(
            "                                                       "
            "          --- HOURS ---"
        )
        print(
            "  # Grade    WG        Target                     "
            "Proposal RA  Req  Est   pct Notes"
        )
        print("-" * 130)
        totreq = 0
        totcorr = 0

        data = self._getSummaryData(sortkey, filter_target, filter_wg)

        prevtid = -1

        for (
            target_id,
            prop_id,
            rank,
            appclass,
            wg,
            name,
            ra,
            hours_requested,
            corrhours,
            hours,
            status,
            percent,
            grade,
        ) in data:

            if int(target_id / self.target_step) == prevtid:
                name = " --> " + name

            clr = ""
            if percent == 0:
                clr = colorama.Fore.RED
            elif percent < 60:
                clr = colorama.Fore.YELLOW

            text = line.format(
                clr=clr,
                tid=target_id,
                pid=prop_id,
                grade=grade,
                wg=wg[0:7],
                name=name,
                req=hours_requested,
                hours=corrhours,
                flag=status,
                ra=ra,
                pct=percent,
            )

            if wrap:
                print((textwrap.fill(text, width=130, subsequent_indent=" " * 85)))
            else:
                print(text)

            totcorr += corrhours
            totreq += hours_requested
            prevtid = int(target_id / self.target_step)

        print("-" * 130)

        print(
            "             Scheduled: {0:8.1f} of {1:8.1f} requested h".format(
                totcorr, totreq
            )
        )

        totaldarkcorr = np.sum(self.effmap[self.boolmap]) * self.hours_per_map_bin

        darkh, darkhcorr = self.hoursOfFreeDarkTime()
        print(
            "              Darkness: {0:8.1f} of {1:8.1f} h are still free".format(
                darkhcorr, totaldarkcorr
            )
        )

    def _getSummaryData(
        self, sortkey="Working_Group_Rank", filter_target=None, filter_wg=None
    ):
        """summarize what was scheduled. This is used by
        printSummary() and other methods that output the text-version
        of the schedule in various formats

        `filter_target`: a regexp to use to filter by target name
        `filter_wg`: regexp filter for working groups
        """
        data = []

        targets = sorted(self.targets.values(), key=itemgetter(sortkey, "INDEX"))

        for targ in targets:
            target_id = targ["INDEX"]
            prop_id = self.proposalID(targ)
            hours, corrhours = self.hoursForTarget(target_id)
            hours_requested = targ["Hours_Accepted"]
            rank = int(targ["Working_Group_Rank"])
            status = ""
            appclass = targ["Approval_Class"]
            grade = targ["Science_Grade"]

            if filter_target and not re.search(filter_target, targ["Target_Name"]):
                continue
            if filter_wg and not re.search(filter_wg, targ["Working_Group"]):
                continue

            percent = 0
            if targ["Hours_Accepted"] > 0:
                if targ["Scheduling_Efficency"] == "ignore":
                    percent = int(
                        round(
                            100
                            - (
                                ((targ["Hours_Accepted"]) - hours)
                                / (targ["Hours_Accepted"])
                            )
                            * 100
                        )
                    )
                else:
                    percent = int(
                        round(
                            100
                            - (
                                ((targ["Hours_Accepted"]) - corrhours)
                                / (targ["Hours_Accepted"])
                            )
                            * 100
                        )
                    )

            delta = round(targ["Hours_Accepted"] - corrhours, 0)

            periods = ",".join(
                [x.split("-")[1] for x in self.periodsForTarget(target_id)]
            )

            if periods != "":
                status += "[{0}]".format(periods)

            if targ["Scheduling_Efficency"] == "ignore":
                delta = round(targ["Hours_Accepted"] - hours, 0)
                status += "(Realtime)"

            if "BELOW_FILL_FRACTION" in targ:
                status += "<FRAC={0:.0f}% ".format(
                    targ["Scheduling_Min_Fraction"] * 100
                )

            name = targ["Target_Name"].strip()  # .replace(" ","_")

            # print a warning if we underfilled this source
            if delta > 1.0:
                status += " {0:5.1f}h ".format(-delta)

            # if some other source in the FOV already got hours, can
            # mention that as well
            nearbytarget_indices = self.nearbyTargets(targ)
            for nearby_target_id in nearbytarget_indices:
                hh, chh = self.hoursForTarget(nearby_target_id)
                if chh > 0.0 and self.isCombined(target_id, nearby_target_id):
                    status += " +{0:.0f}h from {1}".format(
                        chh, self.getTarget(target_id)["Target_Name"]
                    )

            data.append(
                (
                    target_id,
                    prop_id,
                    rank,
                    appclass,
                    targ["Working_Group"],
                    name,
                    targ["RA_2000"],
                    hours_requested,
                    corrhours,
                    hours,
                    status,
                    percent,
                    grade,
                )
            )

        return data

    def isCombined(self, target_id, nearby_target_id):
        """ return true if target id is a sub-target of nearby_target_id """
        return int(nearby_target_id / self.target_step) != int(
            target_id / self.target_step
        )

    @property
    def score(self):
        """returns a score measure of the current schedule for use
        with optimization algorithms.  Currently this is a bit
        simplistic and probably needs some better weighting.
        """
        score = 0
        rsum = 0
        for target_id in self.targets:
            rank = float(self.getTarget(target_id)["Working_Group_Rank"])
            _, corrhours = self.hoursForTarget(target_id)
            hours_requested = self.getTarget(target_id)["Hours_Accepted"]
            score += (corrhours - hours_requested) / (rank + 0.1)
            rsum += rank + 0.1

        return score / rsum

    def diff(self, dark):
        """
        Prints the differences between two darkness objects, useful
        for checking exactly what happens when you schedule
        differently.

        Parameters
        ----------
        dark: hessobs.darkness.Darkness
            other schedule to compare with
        """

        tdict = target_list_to_dict(list(dark.targets.values()), key="Entry")

        for targ in self.targets.values():

            entry = targ["Entry"]

            if not entry in tdict:
                print(
                    "ADDED: ",
                    targ["Target_Name"],
                    ": {0:+5.1f} hrs".format(self.hoursForTarget(targ["INDEX"])[1]),
                )
                continue

            othertarg = tdict[entry]
            otheridx = othertarg["INDEX"]

            _, esthrs = self.hoursForTarget(targ["INDEX"])
            _, oesthrs = dark.hoursForTarget(otheridx)
            deltat = esthrs - oesthrs

            if np.fabs(deltat) > 1.0:
                print("{1:+5.1f} hrs : {0}".format(targ["Target_Name"], deltat))

        # check for removed sources:
        tdict = target_list_to_dict(list(self.targets.values()), key="Entry")
        for targ in list(dark.targets.values()):
            entry = targ["Entry"]
            if entry not in tdict:
                print(
                    "REMOVED: ",
                    targ["Target_Name"],
                    ": -{0:5.1f} hrs".format(self.hoursForTarget(targ["INDEX"])[0]),
                )
                continue

    def _getPeriodSubMap(self, period, themap=None, withdates=False):
        """
        returns just the section of the overall map that
        corresponds to a single period.  if widthdates=True, you also
        get the date range corresponding to the period

        Parameters
        ----------
        self: type
            description
        period: int or str
            period number or name
        themap: numpy.ndarray
            which map to use as the master map (if None, the schedule
            map is used), but self.ramap, etc can also be used)
        withdates: bool
            return the date map as well

        Returns
        -------
        a sub-map or (sub_map, date_map) if `with_dates`  is True
        """

        period = self.periodName(period)

        if themap is None:
            themap = self.map

        if period is None:
            if withdates:
                return themap, self.map_fdates
            else:
                return themap

        bins = np.arange(len(self.map_dates))
        drange = self.getDateRangeForPeriod(period)
        fullrange = bins[(self.map_dates >= drange[0]) * (self.map_dates <= drange[1])]
        lo = fullrange[0]
        hi = fullrange[-1]
        submap = themap[lo:hi]

        if withdates:
            return submap, self.map_fdates[lo:hi]
        else:
            return submap

    def printSchedule(self, period, withrequests=True, withcomments=True):
        """
        prints the objects scheduled for given period, with hours

        Parameters
        ----------
        self: type
            description
        period: int or str
            period name or number
        withrequests: bool
            include special requests (per target)
        withcomments: bool
            include proposal comments (per proposal)
        """

        period = self.periodName(period)

        print("=" * 79)
        print(self._name, "PERIOD:", period)
        print("=" * 79)
        print("  RawH EstH Rnk TARGET                 ZENIT WOB PROPOSAL DATAQUAL")

        submap = self._getPeriodSubMap(period)

        wrap = textwrap.TextWrapper(
            initial_indent=" " * 18,  # + "\\-> ",
            subsequent_indent=" " * 18,  # + "\\-> ",
            width=65,
        )

        targs = np.unique(np.sort(submap[submap > Darkness.UNFILLED].flatten()))

        for target_id in targs:
            name = (
                colorama.Style.BRIGHT
                + self.getTarget(target_id)["Target_Name"]
                + colorama.Style.RESET_ALL
            )
            hours, hours_eff = self.hoursForTarget(target_id, period=period)
            zen_min = self.getTarget(target_id)["Zenith_Min"]
            zen_max = self.getTarget(target_id)["Zenith_Max"]
            wobble = self.getTarget(target_id)["Wobble_Offset"]
            rank = self.getTarget(target_id)["Working_Group_Rank"]
            year = self.getTarget(target_id)["Year"]
            seqno = self.getTarget(target_id)["Seqno"]
            qual = self.getTarget(target_id)["Required_Data_Quality"]
            # skip sources that receive too little time this period
            if hours_eff < self.MIN_TIME_PER_PERIOD:
                continue

            line = "* {0:4.1f} {1:4.1f} {2:3d} {3:30s} {4:2.0f} {5:2.0f} {6:2.1f}"
            # if (self._isSubTarget(target_id)):
            #     line = "   also     {2:3d} {3:30s} {4:2.0f} {5:2.0f} {6:2.1f}"

            line += " {7:4d}-{8:02d} {9:10s}"
            line = line.format(
                hours,
                hours_eff,
                rank,
                name,
                zen_min,
                zen_max,
                wobble,
                year,
                seqno,
                qual,
            )

            print(line)

            if withrequests:
                com = self.getTarget(target_id)["Comments"]
                spec = self.getTarget(target_id)["Special_Requests"]
                req = ""
                if com and withcomments:
                    req += com
                if not (req is None or req == ""):
                    req += ". "
                if spec:
                    req += spec
                if not (req is None or req == ""):
                    req += ". "

                if self.getTarget(target_id)["Scheduling_Efficency"] == "ignore":
                    req += "Should be filled in real-time hours."
                if req != "" and req is not None:
                    print(
                        colorama.Style.DIM + wrap.fill(req) + colorama.Style.RESET_ALL
                    )
        free, free_eff = self.hoursForTarget(self.UNFILLED, period=period)
        if free > 0.1:
            print("* free time: {0:.1f}h ({1:.1f}h effective)".format(free, free_eff))

    def printAllSchedules(self):
        for ii in range(1, 12, 1):
            self.printSchedule(ii)
            print("")

    def _on_click(self, event):
        """
        matplotlib callback function used to insert a label when the mouse is
        clicked
        """
        target_id = self._getTargetIndexForPosition(event.xdata, event.ydata)
        name = ""
        if target_id == Darkness.UNFILLED:
            name = "FREE DARKTIME"
            print("Clicked on FREE DARKTIME")
        elif target_id == Darkness.RESERVED:
            name = "Reserved Darktime"
        elif target_id > Darkness.UNFILLED:
            try:
                name = self.getTarget(target_id)["Target_Name"]
            except:
                print("couldn't lookup target_id", target_id)

        if event.button == 1:
            txt = plt.text(
                event.xdata,
                event.ydata,
                name,
                fontsize=10,
                color="k",
                horizontalalignment="center",
                verticalalignment="center",
                fontweight="bold",
                rotation=self.label_angle,
            )
            txt.set_path_effects([PathEffects.withStroke(linewidth=3, foreground="w")])
            plt.gcf().canvas.draw()
        else:
            print(self.getTarget(target_id))

    def on_save_clicked(self, event):
        print(event)

    def get_status_at_point(self, xx, yy):
        target_id = self._getTargetIndexForPosition(xx, yy)
        name = ""
        text = None
        try:
            name = "FREE"
            h = 0
            ch = 0
            if target_id > self.UNFILLED:
                name = self.getTarget(target_id)["Target_Name"]
                rank = self.getTarget(target_id)["Working_Group_Rank"]
                h, ch = self.hoursForTarget(target_id)
                pid = self.proposalID(self.getTarget(target_id))[5:]
                # ra = self._getRAForPosition( event.xdata, event.ydata )

                text = "{0} [{1}] R{4} {2:.1f}h p{3}".format(
                    name, target_id, ch, pid, rank
                )
            elif target_id == self.RESERVED:
                text = "reserved"
            elif target_id == self.UNFILLED:
                text = "Free Darktime"
        except:
            pass

        return text

    def _on_motion(self, event):
        """
        matplotlib callback function used to display target under
        mouse cursor in the status line
        """
        text = self.get_status_at_point(event.xdata, event.ydata)

        if text is not None:
            event.canvas.toolbar.set_message(text)

    def _getRAForPosition(self, fdate, utc):
        """
        Returns RA for given position in the map

        Parameters
        ----------
        self: type
            description
        fdate: float
            floating point date representation (x-coordinate in map)
        utc: float
            UTC time as a float (y-coordinate in map)
        """

        ii = np.digitize([fdate], self.map_fdates)
        jj = np.digitize([utc], self.map_utcs)

        try:
            val = self.ramap[ii - 1, jj - 1]
            return float(val)
        except:
            return float(-1)

    def _getTargetIndexForPosition(self, fdate, utc):
        """ returns target INDEX for given position in the map """

        ii = np.digitize([fdate], self.map_fdates)
        jj = np.digitize([utc], self.map_utcs)

        try:
            val = self.map[ii - 1, jj - 1][0]
            return val
        except:
            return -1

    def nearbyTargets(self, target, radius_deg=2.0):
        """
        returns (bool,[target_indices]) for targets that are close to
        this one
        """

        ra = target["RA_2000"] * 180.0 / 12.0  # ra in deg
        dec = target["Dec_2000"]

        close_targets = []

        for targ in self.targets.values():

            if targ is target:
                continue

            tra = targ["RA_2000"] * 180.0 / 12.0
            tdec = targ["Dec_2000"]
            dist = coordinates.ang_sep_deg(ra, dec, tra, tdec)

            if dist < radius_deg:  # and start == tstart:
                close_targets.append(targ["INDEX"])

        return close_targets

    @lru_cache()
    def _generateZenithAngleMap(self, ra, dec):
        dd, uu = self.date_time_map
        return 90.0 - coordinates.radec_to_altaz(ra, dec, dd + uu / 24.0)[0].transpose()

    def zenithRangeForTarget(self, target_id):
        """ returns scheduled zenith angle range for target """
        ra = self.getTarget(target_id)["RA_2000"]
        dec = self.getTarget(target_id)["Dec_2000"]
        zmap = self._generateZenithAngleMap(ra, dec)
        schedzmap = zmap * (self.map == target_id)
        del zmap
        return ((schedzmap[schedzmap > 0.1]).min(), schedzmap.max())

    def generateZenithAngleMapByTarget(self):
        print("Generating zenith angle map (may take some time)...")
        zmap = np.zeros_like(self.map, dtype=np.float)
        for target_id in self.targets:

            if np.sum(self.map == target_id) < 0:
                continue

            tzmap = self._generateZenithAngleMap(
                self.getTarget(target_id)["RA_2000"],
                self.getTarget(target_id)["Dec_2000"],
            )
            schedzmap = tzmap * (self.map == target_id)
            zmin = schedzmap[schedzmap > 0.1]
            if len(zmin) > 0:  # otherwise get error if there are no
                # non-zero bins
                zmin = zmin.min()
            else:
                zmin = 0

            print(
                "\t{3:4d} {0:50s} {1:4.1f} {2:4.1f}".format(
                    self.getTarget(target_id)["Target_Name"],
                    zmin,
                    schedzmap.max(),
                    target_id,
                )
            )

            zmap += schedzmap
            del schedzmap
        return zmap

    def makeSubarrayMap(self, subarray="CT5 Mono"):
        """
        Returns a boolean map of the regions where targets that specify the
        given subarray are scheduled
        """

        # find targets that match the subarray:
        tids = [t.INDEX for t in self.targets.values() if t.Subarray == subarray]

        # generate the map:
        smap = np.zeros_like(self.map)
        for target_id in tids:
            smap[self.map == target_id] = 1

        return smap


# ============================================================================
# Functions to store and restore darnkess objects
# ============================================================================


def save_dark(dark, filename):
    """ save a Darkness object to a file """
    darkfile = open(filename, "wb")
    pickle.dump(dark, darkfile)
    darkfile.close()


def load_dark(filename):
    """ load a Darkness object from a file """
    darkfile = open(filename, "rb")
    dark = pickle.load(darkfile)
    darkfile.close()
    return dark
